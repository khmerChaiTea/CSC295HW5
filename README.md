# CSC295_HW5

Implementation Approach
The primary goal of this assignment was to determine whether the parentheses in a given expression are balanced using a stack. A stack is an ideal data structure for this task due to its Last-In-First-Out (LIFO) nature. By pushing every opening parenthesis (‘(‘, ‘{‘, ‘[‘) onto the stack and popping the stack for every closing parenthesis (‘)’, ‘}’, ‘]’), we can ensure that every closing parenthesis has a corresponding opening parenthesis. This method effectively tracks the correct nesting and order of the parentheses.
The logic behind the ‘isBalanced’ method involves iterating through the characters of the expression. If an opening parenthesis is encountered, it is pushed onto the stack. When a closing parenthesis is encountered, the method checks if there’s a corresponding opening parenthesis on top of the stack. If the stack is empty or the types of parentheses do not match, the method returns ‘false’, indicating an unbalanced expression. The expression is considered balanced if the stack is empty after processing all characters.
Challenges
The primary challenge in this assignment was handling edge cases. For instance, an expression without any parentheses or an empty string should still be considered balanced. Moreover, efficiency was a consideration since the stack operations (push and pop) have a time complexity of O(1). Ensuring that the algorithm correctly handles mixed types of parentheses (‘()’, ‘{}’, ‘[]’) and identifies mismatches was crucial. This was particularly challenging when the expression contained different types of brackets in various combinations.
Another challenge was managing the stack’s state correctly, especially in scenarios where there were more closing brackets than opening ones or mismatched pairs. In these cases, returning ‘false’ immediately was necessary to avoid unnecessary stack operations and ensure the method’s efficiency.
Unit Testing
Unit testing played a vital role in validating the correctness of the ‘isBalanced’ method. By writing tests for various scenarios—single-type brackets, mixed-type brackets, balanced and unbalanced expressions, and edge cases like an empty string—I was able to ensure that the method handles all possible inputs as expected. These tests helped catch any potential bugs and verified that the logic implemented was correct. Additionally, writing tests before coding allowed me to adopt a test-driven development approach, ensuring that the code met the requirements from the outset.
